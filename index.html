<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Space Invaders</title>

  <!-- Prism.js syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-c.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>

  <!-- Includes the stylesheet file styles.css -->
  <link rel="stylesheet" href="styles.css" />
</head>

<body>
  <!-- Fixed Navigation Menu -->
  <nav id="menu">
    <h3>Menu</h3>
    <ul>
      <li><a href="#top">Title</a></li>
      <li><a href="#information">Project Information</a></li>
      <li><a href="#introduction">Introduction</a></li>
      <li><a href="#circuit-diagram">Circuit</a></li>
      <li><a href="#environment">Environment</a></li>
      <li><a href="#bom">BoM</a></li>
      <li><a href="#prototype">Prototype</a></li>
      <li><a href="#code">Code</a></li>
      <li><a href="#conclusion">Conclusion</a></li>
      <li><a href="#references">References</a></li>
    </ul>
  </nav>


  <h1 id="top">Space Invaders Game</h1>

  <section id="information">
    <h2>Project Information</h2>
    <p><strong>Course:</strong> TECH 117 (Computer Engineering Technology, Fall 2025)</p>
    <p><strong>Instructor:</strong> Ph.D. Ana Rodrigues</p>
    <p><strong>Team Members:</strong></p>
    <ul>
      <li>...Kymani Whitehead</li>
      <li>...Alijah Murphy-Lewis</li>
      <li>...Pasha Herd</li>
      <li>...</li>
    </ul>
  </section>

  <section id="introduction">
    <h2>Introduction</h2>
       <p>This project uses multiple components on a breadboard to deliver a classic Space Invaders game experience.
      Players control a laser cannon to shoot descending aliens while avoiding their attacks.
       </p>
  </section>

  <section id="circuit-diagram">
    <h2>Circuit Diagram</h2>
    <p>SMRZA Microcontroller feed data to OLED Display and Dual Axis Joystick to interface the Space Invaders Gameplay.</p>
    <img src="./assets/micro-controller.jpeg" alt="">
  </section>

  <section id="environment">
    <h2>Environmental Impact Assessment</h2>
<ul>
  <li><strong>Sources:</strong> All project components—including the microcontroller, joystick module, OLED display, 
    jumper wires, and breadboard—were sourced from a single online supplier, reducing excess packaging and unnecessary shipments.</li>

  <li><strong>Energy Efficiency:</strong> The setup operates at very low power (typically under ~100 mA at 5V), making it suitable 
    for USB power or integration with small renewable energy sources.</li>

  <li><strong>Reusability:</strong> Every part of the prototype is fully modular. The breadboard, microcontroller, and sensor modules 
    can be reused in future projects, significantly reducing long-term electronic waste.</li>

  <li><strong>Packaging & Shipping:</strong> Consolidating all parts into one shipment helps minimize transportation emissions and 
    lowers the overall carbon footprint of the project.</li>
</ul>
  </section>

  <section id="bom">
    <h2>Bill of Materials (BoM)</h2>
    <table>
      <thead>
        <tr>
          <th>OLED - Display</th>
          <th></th>
          <th>Amazon.ca</th>
          <th>$13.42</th>
          <th>1x</th>
        </tr>
        <tr>
          <th>Dual Axis Joystick</th>
          <th></th>
          <th>Amazon.ca</th>
          <th>$4.00</th>
          <th>1x</th>
        </tr>
        <tr>
          <th>SMRZA - Microcontroller</th>
          <th></th>
          <th>Amazon.ca</th>
          <th>$27.20</th>
          <th>1x</th>
        </tr>
        <tr>
          <th>Breadboard</th>
          <th></th>
          <th>Amazon.ca</th>
          <th>$6.00</th>
          <th>1x</th>
        </tr>
        <tr>
          <th>Jumper Wire</th>
          <th></th>
          <th>Amazon.ca</th>
          <th>$6.00</th>
          <th>1x</th>
        </tr>
      </tbody>
      <tfoot>
        <tr>
          <td colspan="3">Estimated Total</td>
          <td>$70.11</td>
          <td>—</td>
        </tr>
      </tfoot>
    </table>
  </section>

  <section id="prototype">
    <h2>Prototype</h2>
    <p>The following image shows the assembled prototype on a breadboard.</p>
    <img src="./assets/main_two.jpeg" alt="Space Invaders Game Prototype">
  </section>

  <section id="code">
    <h2>Arduino Code</h2>
    <p>The following code runs on the micro-controller that manages the Space Invader Game Engine</p>

    <pre class="line-numbers">
  <button class="copy-btn" onclick="copyCode()">Copy</button>
  <code id="arduinoCode" class="language-cpp">
/*
  Space Invaders - Text-style clone for 128x64 OLED (U8x8lib)
  Controls:
    - Move: joystick X (A0)
    - Fire: joystick button (SW) on pin 4 (wired to GND when pressed)
  Libraries required:
    - U8x8lib (already used in your previous sketches)
*/

#include <Wire.h>
#include <U8x8lib.h>

// Display (text mode on 128x64)
U8X8_SSD1306_128X64_NONAME_HW_I2C display(U8X8_PIN_NONE);

// Joystick
#define JOY_X A0
#define JOY_BTN 4

// Screen grid (U8x8 text grid)
const int COLS = 16;   // x positions 0..15
const int ROWS = 8;    // y positions 0..7

// Player
int playerX = COLS/2;
const int PLAYER_Y = 7;
int lives = 3;
unsigned long lastPlayerMove = 0;
const unsigned long playerMoveDelay = 90; // ms between moves from joystick

// Player bullets (upwards)
const int MAX_PLAYER_BULLETS = 2;
bool pBulletActive[MAX_PLAYER_BULLETS];
int pBulletX[MAX_PLAYER_BULLETS];
int pBulletY[MAX_PLAYER_BULLETS];

// Enemy formation
const int ENEMY_ROWS_START = 3;
const int ENEMY_COLS = 6;
int enemyRows = ENEMY_ROWS_START;
struct Enemy {
  int x;
  int y;
  bool alive;
  byte type; // future use for different sprites/points
};
Enemy enemies[ENEMY_ROWS_START * ENEMY_COLS];

// Enemy group movement
int enemyDir = 1;            // 1 right, -1 left
int enemyLeftBound = 0;
int enemyRightBound = COLS - 1;
unsigned long lastEnemyMove = 0;
unsigned long enemyMoveInterval = 600; // ms, decreases with levels
int enemyStepDown = 0;

// Enemy bullets (downwards)
const int MAX_ENEMY_BULLETS = 3;
bool eBulletActive[MAX_ENEMY_BULLETS];
int eBulletX[MAX_ENEMY_BULLETS];
int eBulletY[MAX_ENEMY_BULLETS];
unsigned long lastEnemyShot = 0;
unsigned long enemyShotInterval = 1500; // ms, decreases with level

// Bunkers (3) - simple health 0..3 (3 = full)
const int NUM_BUNKERS = 3;
int bunkerX[NUM_BUNKERS];
int bunkerY = 5;
int bunkerHealth[NUM_BUNKERS];
const int BUNKER_MAX_HEALTH = 3;

// Game state
int score = 0;
int level = 1;
bool gameRunning = false;
bool inStartScreen = true;
unsigned long lastFirePress = 0; // debounce for joystick button
const unsigned long fireDebounce = 140;

// Timing for redraw step (keeps stable framerate)
unsigned long lastFrame = 0;
const unsigned long frameDelay = 40; // ~25 FPS

// Helper function prototypes
void startNewGame();
void spawnEnemies();
void resetBullets();
void resetBunkers();
void playerTryFire();
void updatePlayerBullets();
void updateEnemyBullets();
void enemyTryShoot();
void updateEnemies();
void detectCollisions();
void drawScreen();
bool anyEnemiesAlive();
void levelUp();
int aliveEnemiesCount();
int pickRandomAliveEnemyColumn(int colIdx);

void setup() {
  display.begin();
  display.setFont(u8x8_font_chroma48medium8_r);

  pinMode(JOY_BTN, INPUT_PULLUP);

  // Initialize arrays
  startNewGame();
}

void loop() {
  unsigned long now = millis();

  // Start screen or running?
  if (inStartScreen) {
    display.clear();
    display.drawString(2, 2, "SPACE INVADERS");
    display.drawString(3, 4, "Press joystick");
    display.drawString(4, 5, "button to start");
    display.drawString(0, 7, "A: move  SW: fire");
    // start game when fire pressed
    if (digitalRead(JOY_BTN) == LOW) {
      delay(100);
      inStartScreen = false;
      gameRunning = true;
      startNewGame();
    }
    delay(80);
    return;
  }

  if (!gameRunning) {
    // Game over display
    display.clear();
    display.drawString(3, 2, "GAME OVER");
    char buf[16];
    sprintf(buf, "Score: %d", score);
    display.drawString(3, 4, buf);
    display.drawString(1, 6, "Press SW to retry");
    if (digitalRead(JOY_BTN) == LOW) {
      delay(180);
      inStartScreen = true;
    }
    delay(80);
    return;
  }

  // Main game loop (non-blocking)
  if (now - lastFrame >= frameDelay) {
    lastFrame = now;

    // Player movement (joystick + simple deadzone)
    int xVal = analogRead(JOY_X);
    if (now - lastPlayerMove > playerMoveDelay) {
      if (xVal < 380) {
        playerX = max(0, playerX - 1);
        lastPlayerMove = now;
      } else if (xVal > 640) {
        playerX = min(COLS - 1, playerX + 1);
        lastPlayerMove = now;
      }
    }

    // Player fire (joystick button)
    if (digitalRead(JOY_BTN) == LOW) {
      if (now - lastFirePress >= fireDebounce) {
        playerTryFire();
        lastFirePress = now;
      }
    }

    // Enemy movement timer
    if (now - lastEnemyMove >= enemyMoveInterval) {
      lastEnemyMove = now;
      updateEnemies();
    }

    // Enemy shooting timer
    if (now - lastEnemyShot >= enemyShotInterval) {
      lastEnemyShot = now;
      enemyTryShoot();
    }

    // Update bullets every frame (smoothness)
    updatePlayerBullets();
    updateEnemyBullets();

    // Collisions (bullets vs enemies, bullets vs bunkers, enemy bullets vs player)
    detectCollisions();

    // Check level completed
    if (!anyEnemiesAlive()) {
      levelUp();
    }

    // Check player death
    if (lives <= 0) {
      gameRunning = false;
    }

    // Draw everything
    drawScreen();
  }
}

/* ---------- Game initialization & helpers ---------- */

void startNewGame() {
  score = 0;
  level = 1;
  lives = 3;
  enemyMoveInterval = 600;
  enemyShotInterval = 1500;
  resetBullets();
  spawnEnemies();
  resetBunkers();
  playerX = COLS / 2;
  inStartScreen = false;
  gameRunning = true;
}

void spawnEnemies() {
  // spawn enemyRows rows and ENEMY_COLS columns
  enemyRows = ENEMY_ROWS_START;
  int idx = 0;
  for (int r = 0; r < enemyRows; r++) {
    for (int c = 0; c < ENEMY_COLS; c++) {
      enemies[idx].alive = true;
      enemies[idx].type = r; // top row type 0, etc
      enemies[idx].x = 1 + c * 2;   // compact spacing (1,3,5,...)
      enemies[idx].y = 1 + r;       // rows 1,2,3
      idx++;
    }
  }
  // update group bounds
  enemyLeftBound = 0;
  enemyRightBound = COLS - 1;
  enemyDir = 1;
  enemyStepDown = 0;
}

void resetBullets() {
  for (int i = 0; i < MAX_PLAYER_BULLETS; i++) pBulletActive[i] = false;
  for (int i = 0; i < MAX_ENEMY_BULLETS; i++) eBulletActive[i] = false;
}

void resetBunkers() {
  int spacing = COLS / (NUM_BUNKERS + 1);
  for (int i = 0; i < NUM_BUNKERS; i++) {
    bunkerX[i] = (i+1) * spacing - 1; // centers
    bunkerHealth[i] = BUNKER_MAX_HEALTH;
  }
}

/* ---------- Player bullets ---------- */

void playerTryFire() {
  // find free slot
  for (int i = 0; i < MAX_PLAYER_BULLETS; i++) {
    if (!pBulletActive[i]) {
      pBulletActive[i] = true;
      pBulletX[i] = playerX;
      pBulletY[i] = PLAYER_Y - 1;
      // small immediate move so fire feels responsive
      pBulletY[i]--;
      return;
    }
  }
}

void updatePlayerBullets() {
  for (int i = 0; i < MAX_PLAYER_BULLETS; i++) {
    if (!pBulletActive[i]) continue;
    // move up each frame
    static unsigned long lastPBMove[MAX_PLAYER_BULLETS] = {0};
    unsigned long now = millis();
    const unsigned long pbStep = 70; // speed of player bullet
    if (now - lastPBMove[i] >= pbStep) {
      lastPBMove[i] = now;
      pBulletY[i]--;
      if (pBulletY[i] < 0) {
        pBulletActive[i] = false;
      }
    }
  }
}

/* ---------- Enemy bullets ---------- */

void enemyTryShoot() {
  // pick a few random alive enemies to shoot based on level and free slots
  int attempts = 2 + level/2; // more attempts at higher levels
  for (int a = 0; a < attempts; a++) {
    // pick random alive enemy index
    int alive = aliveEnemiesCount();
    if (alive == 0) return;

    int pick = random(0, alive);
    int idx = -1;
    // map pick to the actual alive enemy index from top-left scan
    int seen = 0;
    for (int i = 0; i < enemyRows * ENEMY_COLS; i++) {
      if (i >= (enemyRows * ENEMY_COLS)) break;
      if (enemies[i].alive) {
        if (seen == pick) {
          idx = i;
          break;
        }
        seen++;
      }
    }
    if (idx < 0) continue;

    // place bullet in a free slot
    for (int b = 0; b < MAX_ENEMY_BULLETS; b++) {
      if (!eBulletActive[b]) {
        eBulletActive[b] = true;
        eBulletX[b] = enemies[idx].x;
        eBulletY[b] = enemies[idx].y + 1;
        break;
      }
    }
  }
}

void updateEnemyBullets() {
  for (int i = 0; i < MAX_ENEMY_BULLETS; i++) {
    if (!eBulletActive[i]) continue;
    static unsigned long lastEBMove[MAX_ENEMY_BULLETS] = {0};
    unsigned long now = millis();
    const unsigned long ebStep = 140; // speed
    if (now - lastEBMove[i] >= ebStep) {
      lastEBMove[i] = now;
      eBulletY[i]++;
      if (eBulletY[i] > PLAYER_Y) {
        eBulletActive[i] = false;
      }
    }
  }
}

/* ---------- Enemy movement & behavior ---------- */

void updateEnemies() {
  // compute bounds of alive enemies
  int left = COLS, right = -1;
  for (int i = 0; i < enemyRows * ENEMY_COLS; i++) {
    if (!enemies[i].alive) continue;
    left = min(left, enemies[i].x);
    right = max(right, enemies[i].x);
  }
  if (right == -1) return; // all dead

  // check if next step hits border
  bool willHitEdge = false;
  if (enemyDir == 1 && right + 1 >= COLS) willHitEdge = true;
  if (enemyDir == -1 && left - 1 < 0) willHitEdge = true;

  if (willHitEdge) {
    // move down instead and reverse
    for (int i = 0; i < enemyRows * ENEMY_COLS; i++) {
      if (!enemies[i].alive) continue;
      enemies[i].y++;
    }
    enemyDir = -enemyDir;
    enemyStepDown++;
    // if enemies reach player's row, that's instant death (lose all lives)
    for (int i = 0; i < enemyRows * ENEMY_COLS; i++) {
      if (enemies[i].alive && enemies[i].y >= PLAYER_Y) {
        lives = 0;
      }
    }
  } else {
    // normal horizontal move
    for (int i = 0; i < enemyRows * ENEMY_COLS; i++) {
      if (!enemies[i].alive) continue;
      enemies[i].x += enemyDir;
    }
  }
}

/* ---------- Collisions ---------- */

void detectCollisions() {
  // Player bullets -> enemies or bunkers
  for (int b = 0; b < MAX_PLAYER_BULLETS; b++) {
    if (!pBulletActive[b]) continue;
    // enemies
    for (int i = 0; i < enemyRows * ENEMY_COLS; i++) {
      if (!enemies[i].alive) continue;
      if (pBulletX[b] == enemies[i].x && pBulletY[b] == enemies[i].y) {
        // hit enemy
        enemies[i].alive = false;
        pBulletActive[b] = false;
        score += 10 + (enemies[i].type * 5); // higher rows worth more
        goto bulletHandled;
      }
    }
    // bunkers
    for (int bk = 0; bk < NUM_BUNKERS; bk++) {
      if (bunkerHealth[bk] <= 0) continue;
      if (pBulletX[b] == bunkerX[bk] && pBulletY[b] == bunkerY) {
        bunkerHealth[bk]--;
        pBulletActive[b] = false;
        goto bulletHandled;
      }
    }
    // no collision -> continue
bulletHandled: ;
  }

  // Enemy bullets -> player or bunkers
  for (int b = 0; b < MAX_ENEMY_BULLETS; b++) {
    if (!eBulletActive[b]) continue;
    // player
    if (eBulletX[b] == playerX && eBulletY[b] == PLAYER_Y) {
      // hit player
      eBulletActive[b] = false;
      lives--;
      // brief flash could be added
      continue;
    }
    // bunkers
    for (int bk = 0; bk < NUM_BUNKERS; bk++) {
      if (bunkerHealth[bk] <= 0) continue;
      if (eBulletX[b] == bunkerX[bk] && eBulletY[b] == bunkerY) {
        bunkerHealth[bk]--;
        eBulletActive[b] = false;
        break;
      }
    }
  }
}

/* ---------- Drawing ---------- */

void drawScreen() {
  display.clear();

  // HUD: score and lives and level
  char hud[20];
  sprintf(hud, "S:%04d L:%d LV:%d", score, lives, level);
  display.drawString(0, 0, hud);

  // draw enemies
  for (int i = 0; i < enemyRows * ENEMY_COLS; i++) {
    if (enemies[i].alive) {
      // choose char by type for some variety
      const char *ch = (enemies[i].type == 0) ? "M" : (enemies[i].type == 1 ? "W" : "V");
      display.drawString(enemies[i].x, enemies[i].y, ch);
    }
  }

  // draw bunkers (visual degrade by health)
  for (int bk = 0; bk < NUM_BUNKERS; bk++) {
    if (bunkerHealth[bk] <= 0) continue;
    // choose char representing bunker health: 3->"@", 2->"#", 1->"="
    const char *bch = bunkerHealth[bk] == 3 ? "@" : (bunkerHealth[bk] == 2 ? "#" : "=");
    display.drawString(bunkerX[bk]-1, bunkerY, bch); // shift left to occupy ~3 columns look
  }

  // draw player
  display.drawString(playerX, PLAYER_Y, "A");

  // draw player bullets
  for (int i = 0; i < MAX_PLAYER_BULLETS; i++) {
    if (pBulletActive[i]) {
      display.drawString(pBulletX[i], pBulletY[i], "|");
    }
  }

  // draw enemy bullets
  for (int i = 0; i < MAX_ENEMY_BULLETS; i++) {
    if (eBulletActive[i]) {
      display.drawString(eBulletX[i], eBulletY[i], "!");
    }
  }
}

/* ---------- Level & helpers ---------- */

bool anyEnemiesAlive() {
  for (int i = 0; i < enemyRows * ENEMY_COLS; i++) {
    if (enemies[i].alive) return true;
  }
  return false;
}

int aliveEnemiesCount() {
  int cnt = 0;
  for (int i = 0; i < enemyRows * ENEMY_COLS; i++) if (enemies[i].alive) cnt++;
  return cnt;
}

void levelUp() {
  level++;
  // speed up enemies and shooting
  if (enemyMoveInterval > 120) enemyMoveInterval -= 70; // faster horizontal moves
  if (enemyShotInterval > 400) enemyShotInterval -= 150;
  // increase rows up to a limit
  if (enemyRows < 5) enemyRows++;
  // respawn enemies with more rows
  int oldRows = enemyRows;
  // recreate enemies array with new row count
  int idx = 0;
  for (int r = 0; r < enemyRows; r++) {
    for (int c = 0; c < ENEMY_COLS; c++) {
      enemies[idx].alive = true;
      enemies[idx].type = r % 3;
      enemies[idx].x = 1 + c * 2;
      enemies[idx].y = 1 + r;
      idx++;
    }
  }
  // optionally refill bunkers a bit
  for (int b = 0; b < NUM_BUNKERS; b++) {
    bunkerHealth[b] = min(BUNKER_MAX_HEALTH, bunkerHealth[b] + 1);
  }
  // small level-up pause/message
  display.clear();
  char buf[16];
  sprintf(buf, "LEVEL %d", level);
  display.drawString(4, 3, buf);
  display.drawString(2, 5, "Get ready...");
  delay(900);
  resetBullets();
}

/* End of sketch */
    </code></pre>

    <script>
      function copyCode() {
        const code = document.getElementById('arduinoCode').innerText;
        navigator.clipboard.writeText(code).then(() => {
          alert('Code copied to clipboard!');
        });
      }
    </script>
  </section>



  <section id="conclusion">
    <h2>Conclusion</h2>
    <p>Overall, this prototype has a relatively small environmental footprint thanks to its low power consumption, reusable components, and consolidated sourcing. By relying on modular hardware and minimizing packaging and shipping waste, the project demonstrates how electronic development can be both functional and environmentally conscious. With responsible disposal and continued reuse of parts, the project remains a sustainable example of hands-on learning and prototyping.</p>
  </section>

 <section id="references">
  <h2>References</h2>
  <p>
    The following external resources and example projects demonstrate related Arduino applications 
    using ultrasonic distance sensors, passive buzzers, and multicolour LEDs:
  </p>

  <ul>
    <li>
      Arduino Project Hub. (n.d.). 
      <em>Ultrasonic sensor projects.</em> 
      Arduino Project Hub. 
      <a href="https://projecthub.arduino.cc/projects/tags/ultrasonic-sensor" target="_blank" rel="noopener noreferrer">
        https://projecthub.arduino.cc/projects/tags/ultrasonic-sensor
      </a>
    </li>

    <li>
      Arduino Project Hub. (n.d.). 
      <em>Buzzer projects.</em> 
      Arduino Project Hub. 
      <a href="https://create.arduino.cc/projecthub/projects/tags/buzzer" target="_blank" rel="noopener noreferrer">
        https://create.arduino.cc/projecthub/projects/tags/buzzer
      </a>
    </li>

    <li>
      Arduino Project Hub. (n.d.). 
      <em>LED projects.</em> 
      Arduino Project Hub. 
      <a href="https://projecthub.arduino.cc/projects/tags/led" target="_blank" rel="noopener noreferrer">
        https://projecthub.arduino.cc/projects/tags/led
      </a>
    </li>

    <li>
      Instructables. (n.d.). 
      <em>Distance measurement using ultrasonic sensor.</em> 
      Instructables. 
      <a href="https://www.instructables.com/Arduino-Distance-Measurement-Using-Ultrasonic-Senso/" target="_blank" rel="noopener noreferrer">
        https://www.instructables.com/Arduino-Distance-Measurement-Using-Ultrasonic-Senso/
      </a>
    </li>

    <li>
      Circuit Basics. (n.d.). 
      <em>How to use an ultrasonic sensor with Arduino.</em> 
      Circuit Basics. 
      <a href="https://www.circuitbasics.com/how-to-use-an-ultrasonic-sensor-with-arduino/" target="_blank" rel="noopener noreferrer">
        https://www.circuitbasics.com/how-to-use-an-ultrasonic-sensor-with-arduino/
      </a>
    </li>

    <li>
      Last Minute Engineers. (n.d.). 
      <em>Ultrasonic sensor tutorial.</em> 
      Last Minute Engineers. 
      <a href="https://lastminuteengineers.com/ultrasonic-sensor-arduino-tutorial/" target="_blank" rel="noopener noreferrer">
        https://lastminuteengineers.com/ultrasonic-sensor-arduino-tutorial/
      </a>
    </li>
  </ul>
</section>



</body>

</html>